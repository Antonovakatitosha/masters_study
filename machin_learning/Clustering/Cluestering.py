import random
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.cluster import DBSCAN
from sklearn.cluster import Birch
from sklearn.cluster import KMeans

# we define the number of points which will be generated as well as the number of expected clusters
length = 300
clusters = 3

# we define the method for point generation in space
# function random.random() generates a random number between 0 and 1 on the x axis
# y axis is generated by calculating the division remainder between the current index and the number of clusters
# in order for y to not be the same for each point, variation is added by generating another random.random() number
# the resulting value is divided by 6 in order to create distance between clusters
# in this way we get 3 defined clusters which are far enough from each other

# random.random() – случайное число в диапазоне от 0.0 до 1.0 (включая 0.0, но исключая 1.0)
points = np.zeros([length, 2])
for i in range(length):
    points[i] = [i % clusters + random.random() / 6, random.random()]

# we observe the distribution of points in space
plt.figure()
plt.scatter(points[:, 1], points[:, 0])
plt.show()

# we define a clustering model using the K-Means algorithm (it is necessary for the number of clusters to be defined)
KM = KMeans(clusters)
KM.fit(points)
predicted = KM.predict(points)
# print(predicted)   # [0 2 1 0 2 1 0 2 1 0 2 1 0 2 1 0 2 1 0 2 1 0 2 1 0 2 1 0 2.....]

# we create a dataframe object which contains point coordinates in space and the predicted clusters
# this dataframe serves as an imitation of the application of clustering in real scenarios (with an existing database)
data = pd.DataFrame(columns=['x', 'y', 'cluster'])
data['x'] = points[:, 1]
data['y'] = points[:, 0]
data['cluster'] = predicted

# we visualize the clusteris by drawing the distribution of points with changed colors depending on the predicted cluster
plt.figure()
plt.title('K-Means clustering')

# В результате создаётся объект GroupBy, который содержит несколько групп, и каждая группа соответствует строкам в data, имеющим одинаковое значение в столбце 'cluster'
groups = data.groupby('cluster')
for name, group in groups:
    # print(name, '///', group)  # name - 0, 1, 2; group - table (x  y  cluster)
    plt.scatter(group.x, group.y)
plt.show()

# we define a clustering model using the BIRCH algorithm (it is not necessary to define the number of expected clusters)
Birch = Birch()
Birch.fit(points)
predicted = Birch.predict(points)

data = pd.DataFrame(columns=['x', 'y', 'cluster'])
data['x'] = points[:, 1]
data['y'] = points[:, 0]
data['cluster'] = predicted

plt.figure()
plt.title('Birch clustering')
groups = data.groupby('cluster')
for name, group in groups:
    plt.scatter(group.x, group.y)
plt.show()

# we define a clustering model using the DBSCAN algorithm
# !!! pay attention to the way of predicting clusters !!!
# DBSCAN does not have a defined predict function, insted it uses fit_predict() which conducts the fit and predict functions simultaneously
# for this reason DBSCAN cannot be used for clustering new data without including other available values from the database
DB = DBSCAN()
DB.fit(points)
predicted = DB.fit_predict(points)

data = pd.DataFrame(columns=['x', 'y', 'cluster'])
data['x'] = points[:, 1]
data['y'] = points[:, 0]
data['cluster'] = predicted

plt.figure()
plt.title('DBSCAN clustering')
groups = data.groupby('cluster')
for name, group in groups:
    plt.scatter(group.x, group.y)
plt.show()